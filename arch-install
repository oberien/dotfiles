#!/bin/bash

# Encryption Setup:
# * Attacker Model: https://md.statshelix.com/kVCPl8VFSnm69WH504T-0g
# * General Idea:
#     * boot-partition on a USB-stick
#     * keyfiles on the same USB-stick
#     * (live archiso on the same USB-stick)
#     * keyfiles parition encrypted with LUKS using a memorized password
#     * even though the swap partition is encrypted with a static key, hibernation
#       is not (yet) supported with these instructions, but support can be added later on.
# * OPAL:
#     * use the SSDs SED (self-encrypting drive) functionality
#     * faster than LUKS if the SSD exceeds ~2.5GB/s
#     * has a data key to encrypt all data with
#     * has an authentication key to encrypt data key with
# * LUKS:
#     * use software encryption to encrypt drives or partitions
#     * slower as encryption is done in the CPU instead of on the drive itself
#     * has a data key to encrypt all data with
#     * has authentication keys to encrypt data key with


# Background: Boot Steps
# * CPU init (e.g. Intel Management Engine)
#     * very small initial binary blob which gets executed when the CPU is powered on
#     * performs small initial checks
# * Firmware
#     * POST: Power-on self-test
#     * checks and tests hardware
#     * e.g. memory-training if required
#     * initializes the hardware including switching to 64bit
#     * loads and provides low-level device drivers
# * UEFI
#     * (technically just an interface to communicate with the firmware;
#       the firmware still does all these steps)
#     * reads boot entries from NVRAM to find registered EFI binaries
#     * scans disks to find EFI System Partitions
#     * loads the first configured available option
#     * if it's an EFI binary boot entry: load it
#     * if it's a disk: look for an EFI system partition on the disk and load `\EFI\BOOT\BOOTx64.EFI`
#     * launches the EFI application
# * Bootmanager / Bootloader
#     * usually that EFI application is a bootmanager like grub or gummiboot / systemd-boot
#     * shows different systems / options to select from
#     * once selected, loads that option's efi application
#     * let's assume a linux kernel from now on
#     * `vmlinuz-linux` is the compressed kernel (indicated by the z)
#     * `vmlinuz-linux` contains an EFISTUB to make the kernel an efi application
#     * in case of old MBR-style loading:
#         * unpacks the kernel
#         * stores it at a specific address
#         * loads the initramfs
#         * stores it at a specific address
#         * creates and initializes a boot config struct at a specific address
#         * jumps to a specific address within the kernel
#         * kernel starts executing code from there
#     * in case of EFISTUB:
#         * load and execute the kernel as an efi binary
#         * -> run its EFISTUB
#     * bootloader can be skipped in favour of direcly launching the kernel's  EFISTUB
# * EFISTUB
#     * load initramfs
#         * if files are passed via commandline using `initrd=/foo/bar`,
#           load those from the same partition as the EFISTUB and merge them
#         * if there is an embedded initramfs in the kernel image, load it
#         * if there is neither an initrd parameter nor an embedded initramfs
#           check the `initrdmem=phys_ptr,size` parameter and load the initramfs from there
#     * unpack the initramfs into memory
#     * mount the unpacked initramfs as `/`
#     * exit_boot_services (stop UEFI boot state)
#     * load the kernel
# * Kernel
#     * loads initial linux hardware drivers
#     * initializes hardware for use with linux
#     * starts `/init` as PID 1
# * /init
#     * runs the hooks declared in `/etc/mkinitcpio.conf`
#     * e.g. loads mods
#     * decrypts and mounts partitions
#     * checks the `root=/dev/xxx` kernel parameter and mounts it as `/new_root`
#     * executes `pivot_root` to switch the rootfs from the initramfs to `/new_root`
#     * executes `/bin/init` as PID 1
# * /bin/init
#     * ususally systemd
#     * analyses the dependency graph of all services
#     * starts all its services
#     * starts everything else, possibly including XServer (XOrg or Wayland)


# Boot Setup with Encryption:
# * initramfs LUKS single disk with `encrypt` hook:
#     * contains hooks which are executed one after another
#     * we add a hook after `keyboard` and `keymap` (to init our usb-keyboard)
#       before `encrypt` (which decrypts `cryptdevice`)
#     * our hook unlocks the keyfiles-partition
#     * links the correct keyfile to `/crypto_keyfile.bin`
#     * kernel parameters: `cryptdevice=...:system root=/dev/mapper/system`
#     * `encrypt` hook uses `/crypto_keyfile.bin` to decrypt the kernel parameter `cryptdevice`
#     * Advantages:
#         * "simple" setup
#         * works surprisingly well out of the box
#     * Disadvantages:
#         * boot partition unecrypted -> must reside on USB-Stick
#         * boot partition needs to be mounted on every system update
#         * -> one USB-stick per device is required
#         * supports only a single encrypted disk with the root partition
# * initramfs LUKS single disk with `sd-encrypt` hook:
#     * similar to `encryt` hook, but supports multiple cryptdevices via /etc/crypttab.initramfs
#     * similar advantages and disadvantages
# * initramfs LVM in LUKS on multiple disks:
#     * our hook unlocks the keyfiles-partition
#     * runs cryptsetup for each disk to-be-decrypted using the keyfiles
#     * kernel parameters: `root=/dev/vg_lvm/system`
#     * same advantages / disadvantages as initramfs LUKS
# * grub CRYPTODISK shim:
#     * UNTESTED
#     * grub supports multi-stage, where stage 1 decrypts the boot partition
#     * stage 1 loads stage 2 from the now decrypted boot partition
#     * stage 2 starts kernel
#     * Advantages:
#         * same grub stage 1 for all devices
#         * USB-stick doesn't need to be connected and mounted during every system update
#         * -> same USB-stick for all devices
#     * Disadvantages:
#         * complex
#         * only works with LUKS1 (a patched grub with partial LUKS2 support exists)
#         * might not work with opal(?)
#         * might not be possible to dynamically switch between opal setup and
#           LUKS setup depending on the system it's connected to
#         * might need modifications to work
#         * if modifications need to be made to grub, why not write a custom bootloader?
# * custom PBA (pre-boot authenticator) / UEFI bootloader (opal-uefi-greeter):
#     * custom bootloader / bootmanager / bootmenu
#     * custom EFI binary
#     * decrypt keyfile partition
#     * check if there are any OPAL-locked SEDs
#     * if yes: decrypt them using keyfiles and chain-load initramfs
#     * if not: decrypt LUKS drives using keyfiles and chain-load initramfs
#     * Advantages:
#         * fancy
#         * full control
#         * can have any and every feature wanted
#     * Disadvantages:
#         * not an easy general-purpose solution
#         * most complex of the solutions


# This "guide" assumes you have an arch-boostrap image.

# partition variables
BOOTPARTITION=/dev/device1
SWAPPARTITION=/dev/device2
SYSTEMPARTITION=/dev/device3
SWAP=/dev/mapper/swap
SYSTEM=/dev/mapper/system

loadkeys de-latin1
setfont lat9w-16

# setup partitions
# If there is a windows instance installed on an msdos partition table, and for
# whatever reason actually want to keep that winodws,
# change to gpt and recreate the windows partition with the exact same sectors.
fdisk /dev/device
    # GPT, needed for EFI
    g
    # boot (EFI)
    n
        1
        default
        +500M
    t
        1
    # SWAP not necessarily needed, sometimes even counterproductive
    n
        2
        default
        +32G
    t
        2
        19
    # Linux System
    n
        3
        default
        default
    w

# Encryption using OPAL (for LUKS see below)

sedutil-cli --scan
sedutil-cli --query /dev/nvmeX
linuxpba # password `debug`
# if you're lucky and the drive supports SED, it should say "is OPAL NOT LOCKED"
# If you're unlucky, it says "not OPAL".
# In that case either your SSD is too old to support OPAL, or you are even more unlucky.
# You may have just gotten an SSD that supports Pyrite instead of OPAL.
# Now you can be really really fucking sad, go into a corner and cry.
# Trusted Computing Group: "Unlike Opalite SSC, Pyrite SSC does not specify encryption of user data."

# Regenerate data encryption key: PSID reset / crypto erase
# You need the PSID, which is printed on the sticker on the SSD.
# ProTip™: there may be a data-matrix code with the PSID (which doesn't really help
# because you're going to type it on the archiso live system but whatever ¯\_(ツ)_/¯)
sedutil-cli --yesIreallywanttoERASEALLmydatausingthePSID <psid> /dev/nvmeX
# should output: `revertTper completed successfully`

sedutil-cli --initialsetup debug /dev/nvmeX
sedutil-cli --enablelockingrange 0 debug /dev/nvmeX
sedutil-cli --setlockingrange 0 lk debug /dev/nvmeX
sedutil-cli --setmbrdone off debug /dev/nvmeX
# OPAL supports that the SSD shows some data when it is not encrypted.
# This can be used to have a PBA on the SDD's MBR.
# When the PC powers on, it sees the PBA EFI binary, loads and executes it,
# which unlocks the drive and reboots.
# As the SSD hasn't lost power, it will stay unlocked.
# After the reboot, the BIOS now sees the actual boot partition and boots Linux.
# The setup in this "guide" stores the PBA on a separate USB-stick, so this
# feature isn't needed.
sedutil-cli --setmbrenable off debug /dev/nvmeX
# test with linuxpba
linuxpba # password `debug`
# should output: `is OPAL Unlocked`


# Encryption using LUKS

# generate random keys
dd if=/dev/urandom of=keyfile_system bs=4096 count=1
dd if=/dev/urandom of=keyfile_swap bs=4096 count=1

# If no keyfile is wanted on an external drive, leave out -d keyfile.
cryptsetup -vd keyfile_system luksFormat $SYSTEMPARTITION
cryptsetup open -d keyfile_system $SYSTEMPARTITION system
# If swap should not be encrypted, leave out this step.
# If no keyfile is wanted on an external drive, leave out -d keyfile. UNTESTED
cryptsetup -vd keyfile_swap luksFormat $SWAPPARTITION
cryptsetup open -d keyfile_swap $SWAPPARTITION swap

# for lvm (above use cryptsetup open with name "lvm" instead of "system")
pvcreate /dev/mapper/lvm
vgcreate vg_lvm /dev/mapper/lvm
lvcreate -L 500G vg_lvm -n system /dev/mapper/lvm
# raid1: lvcreate --type raid1 --mirrors 1 -L 200G vg_lvm -n home /dev/mapper/lvm /dev/mapper/lvm2
# if raid is used, add the modules dm_raid and raid1 to /etc/mkinitcpio.conf
lvcreate -L 200G vg_lvm -n home /dev/mapper/lvm
# convert to raid1 later on: lvconvert --type raid1 --mirrors 1 vg_lvm/home /dev/mapper/lvm /dev/mapper/lvm2
... others
# for non-lvm
mkfs.ext4 $SYSTEM

# boot
mkfs.fat -F32 $BOOTPARTITION
# swap
# If swap was set up without encryption, use $SWAPPARTITION instead of $SWAP.
mkswap $SWAP
swapon $SWAP

# mount everything
# lvm: mount /dev/vg_lvm/system /mnt
mount $SYSTEM /mnt
mkdir /mnt/boot
mount $BOOTPARTITION /mnt/boot


# pacstrap
# For a setup with wayland and sway use this instead: UNTESTED
# pacstrap -i /mnt base base-devel git net-tools networkmanager wayland sway gnome-terminal cmake

# For a setup with gnome and wayland (wayland is default for gnome).
# Using gnome you need to have `exec gnome-session` in you .xinitrc.
# Additionally if you want to use gdm, run `systemctl enable gdm.service` in the new system
# pacstrap -i /mnt base base-devel zsh git net-tools networkmanager network-manager-applet gvim cmake gnome gnome-extra

# For xorg and i3:
pacstrap -i /mnt base base-devel zsh git net-tools networkmanager network-manager-applet xorg-xserver xorg-xinit xorg-apps rxvt-unicode i3 dmenu gvim cmake


genfstab -U /mnt > /mnt/etc/fstab
# make sure everything is correct
cat /mnt/etc/fstab

arch-chroot /mnt /bin/zsh

# locale
nano /etc/locale.gen # uncomment en_US.UTF-8 UTF-8 or the language of your choice
locale-gen
echo LANG=en_US.UTF-8 > /etc/locale.conf # use the uncommented language here
echo -e "KEYMAP=de-latin1\nFONT=lat9w-16" > /etc/vconsole.conf
ln -sf /usr/share/zoneinfo/Europe/Berlin /etc/localtime
hwclock --systohc --utc

# hostname
echo myhostname > /etc/hostname
nano /etc/hosts # add 'myhostname' to end of each line

# setup boot
bootctl install
bootctl update

# create user
useradd NAME -m -g users -G wheel -s /bin/zsh 
nano /etc/sudoers # uncomment %wheel
# Using the group sudo may work as well (@main--), but I only had success with wheel.

# dotfiles 'n stuff
  # change user to created one
  # setup dotfiles
  # if using lvm, add the "lvm2" hook after the "encrypt" hook in dotfiles/paranoid/mkinitcpio.conf
  # setup paranoid_link if an external drive is used to store the encryption keys
  # edit files for paranoid stuff

# generate bootimage and entries
# if using lvm, use cryptdevice=...:lvm root=/dev/vg_lvm/system
mkinitcpio -p linux
cat <<_EOF_ > /boot/loader/entries/arch.conf
title       Arch Linux
linux       /vmlinuz-linux
initrd      /initramfs-linux.img
options     cryptdevice=$SYSTEMPARTITION:system root=$SYSTEM
_EOF_

# If multiple entries exist, timeout should be non-zero
cat <<_EOF_ > /boot/loader/loader.conf
default arch
timeout 0
_EOF_

# TODO
# If there is a dual-boot Windows, which doesn't show up automatically
cat <<_EOF_ > /boot/loader/entries/windows.conf
title Windows
_EOF_

# alacritty, nushell, delta
pacman -S alacritty
pikaur -S xcwd
pikaur -S nushell-git # use https://github.com/oberien/nushell.git for now until #2296 is merged
pikaur -S git-delta-bin

# important packets
pacman -S python3
pacman -S python2
pacman -S arandr
pacman -S ttf-dejavu
pacman -S ttf-symbola
pacman -S wget
pacman -S openssh
pacman -S openvpn

# pikaur instead of aurman, because aurman became weird after a few updates
# aurman instead of pacaur, because pacaur is ded since pacman 5.1.0
# pacaur instead of yaourt, because it's secure™
# adapted from https://gist.github.com/Tadly/0e65d30f279a34c33e9b
mkdir -p /tmp/pikaur_install
pushd /tmp/pikaur_install
sudo pacman -S python expac python-requests git python-regex python-dateutil pyalpm python-feedparser --noconfirm --needed
curl -o PKGBUILD "https://aur.archlinux.org/cgit/aur.git/plain/PKGBUILD?h=pikaur"
makepkg PKGBUILD --install --needed
popd
rm -rf /tmp/pikaur_install

# make aur builds faster
# add `MAKEFLAGS="-j$(nproc)"`
nano /etc/makepkg.conf

# setup neo-layout
pikaur -S kbd-neo
localectl set-keymap --no-convert de neo
localectl set-x11-keymap --no-convert de thinkpad neo

# ibus
pacman -S ibus
# if not there add `exec ibus-daemon -drx` to your i3-config
# if not there, add the following lines to `/etc/environment`
GTK_IM_MODULE=ibus
QT_IM_MODULE=ibus
XMODIFIERS=@im=ibus

# plover
pikaur -S plover-git
sudo gpasswd -a `whoami` uucp
# configure plover for Gemini and to start on boot

# notification daemon
pacman -S dunst

# browser
pikaur -S vivaldi
pacman -S firefox
pacman -S gst-libav

# useful others
pikaur -S urxvt-font-size-git
pacman -S zathura zathura-pdf-mupdf
pacman -S feh
pacman -S imagemagick
pacman -S htop iotop
pacman -S unzip
pacman -S nmap
pacman -S mlocate
pacman -S gedit
pacman -S tree
pacman -S dosfstools
pacman -S ntfs-3g
pacman -S ncdu

# media
pacman -S mpd
pacman -S mpc
pacman -S mpv

# others
pacman -S ffmpeg
pacman -S mumble
pacman -S pulseaudio
pacman -S pavucontrol
pikaur -S pulseaudio-ctl
pacman -S thunderbird

# jack / sound
pacman -S realtime-privileges
gpasswd -a $USER realtime
pacman -S cadence carla
pacman -S jack2 lib32-jack2
pacman -S pulseaudio-jack
# comment out the `Exec=`-line in /usr/share/dbus-1/services/org.jackaudio.service

# obs / webcam
pacman -S obs-studio
# webcam loopback
pacman -S v4l2loopback-dkms
pikaur -S obs-v4l2sink
sudo modprobe v4l2loopback devices=1 video_nr=10 card_label="OBS Cam" exclusive_caps=1

# xmpp
pacman -S gajim python-axolotl python-pillow
# Plugins: OMEMO, Url image preview

# mysql
pacman -S mariadb
sudo mysql_install_db --user=mysql --basedir=/usr --datadir=/var/lib/mysql
mysql_secure_installation
pacman -S dnsutils

# steam
# enable multilib in /etc/pacman.conf
pacman -Syu
pikaur -S steam

# other fonts used for games/wine/vim
pikaur -S ttf-tahoma
pikaur -S ttf-ms-fonts
pikaur -S ttf-dejavu-sans-mono-powerline-git

# java
pacman -S jdk8-openjdk
pacman -S openjdk8-src
pacman -S openjdk8-doc
pikaur -S intellij-idea-ultimate-edition

# rust
pacman -S rustup

# maybe
pacman -S gparted
pacman -S gucharmap

# cups (not working ☹)
pacman -S avahi
pacman -S cups
sudo gpasswd -a `whoami` lp
sudo gpasswd -a `whoami` sys
# drivers, install required ones
pacman -S gutenprint # Canon, Epson, Lexmark, Sony, Olympus, PCL
pacman -S foomatic foomatic-db foomatic-db:engine, foomatic-db-ppd foomatic-filters
pacman -S hplip # HP
pacman -S splix # Samsung
pacman -S cups-pdf # Print to PDF
systemctl enable avahi-dnsconfd.service
systemctl enable org.cups.cupsd.service
systemctl enable cups-browsed.service
systemctl start avahi-dnsconfd.service
systemctl start org.cups.cupsd.service
systemctl start cups-browsed.service
